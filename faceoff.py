import argparse
import cv2
import gradio as gr
import warnings
import numpy as np
import os
import os.path as osp
import time
import shutil
import subprocess
import insightface
from insightface.app import FaceAnalysis
from PIL import Image

assert insightface.__version__ >= '0.7'

# Ignore specific warnings
warnings.filterwarnings('ignore')

# Set file paths
source_image_path = os.path.join('images/source', 'source.jpg')
destination_image_path = os.path.join('images/destination', 'destination.jpg')

def face_swap(source_image, destination_image):
    # Initialize face analysis and swapper models
    app = FaceAnalysis(name='buffalo_l')
    app.prepare(ctx_id=0, det_size=(640, 640))
    swapper = insightface.model_zoo.get_model('inswapper_128.onnx')

    # Detect and swap faces
    faces_source = app.get(source_image)
    if len(faces_source) != 1:
        raise ValueError("Source image should have exactly one face!")
    source_face = faces_source[0]

    faces_destination = app.get(destination_image)
    res = destination_image.copy()
    for face in faces_destination:
        res = swapper.get(res, face, source_face, paste_back=True)

    return res

def faceoff(source_image_path, destination_image_path, output_dir, enhance_method):
    source_image = cv2.imread(source_image_path)
    destination_image = cv2.imread(destination_image_path)

    # Store the original destination image size
    original_size = destination_image.shape[:2]

    # Perform face swapping
    swapped_image = face_swap(source_image, destination_image)

    # Save the swapped image
    os.makedirs(output_dir, exist_ok=True)
    output_file = osp.join(output_dir, f'output_{int(time.time())}.png')
    cv2.imwrite(output_file, swapped_image)
    print("Face swapping completed.")

    # Determine the enhance method to use
    if enhance_method == "Real-ESRGAN":
        # Call the Real-ESRGAN/GFPGAN inference script
        realesrgan_dir = osp.join(os.getcwd(), "Real-ESRGAN")  # Get the absolute path to the Real-ESRGAN directory
        command = f'python inference_realesrgan.py -n RealESRGAN_x4plus -i {output_file} --outscale 3.5 --face_enhance --fp32 --tile 256 -o results'
        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, cwd=realesrgan_dir)
        process.wait()
        print("Real-ESRGAN inference completed.")

        # Get the enhanced output file (generated by Real-ESRGAN script)
        file_prefix = osp.splitext(osp.basename(output_file))[0]
        enhanced_output_file = osp.join(realesrgan_dir, "results", f"{file_prefix}_out.png")

        # Check if the enhanced output file exists before trying to read it
        if not os.path.exists(enhanced_output_file):
            print(f"Error: The file at {enhanced_output_file} does not exist.")
            return None
    elif enhance_method == "CodeFormer":
        # Call the CodeFormer inference script
        codeformer_dir = os.getcwd()  # Root directory of the project
        codeformer_output_dir = osp.join(codeformer_dir, "results", "test_img_1.0", "final_results")
        os.makedirs(codeformer_output_dir, exist_ok=True)
        codeformer_output_file = osp.join(codeformer_output_dir, f"output_{int(time.time())}")
        command = f'python inference_codeformer.py --bg_upsampler realesrgan --face_upsample -w 1.0 --input_path {output_file} --output_path {codeformer_output_file}'
        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, cwd=codeformer_dir)
        process.wait()
        print("CodeFormer inference completed.")

        # Get the enhanced output file (generated by CodeFormer script)
        enhanced_output_file = osp.join(codeformer_output_dir, osp.basename(codeformer_output_file), f"final_results", f"{osp.basename(codeformer_output_file)}.png")
    else:
        print(f"Error: Invalid enhance method '{enhance_method}'")
        return None

    # Read the enhanced output image
    enhanced_output_image = cv2.imread(enhanced_output_file)

    # Resize the enhanced output image
    resized_image = None
    if enhanced_output_image is not None:
        try:
            # Calculate the scaling factor based on the original destination image size
            scaling_factor = min(original_size[1] / enhanced_output_image.shape[1], original_size[1] / enhanced_output_image.shape[0])
            resized_image = cv2.resize(enhanced_output_image, None, fx=scaling_factor, fy=scaling_factor)
        except cv2.error as e:
            print(f'Error: OpenCV could not resize the image. {e}')

    if resized_image is not None:
        # Create the directory for resized images
        resized_output_dir = osp.join(output_dir, 'images', 'output', 'images')
        os.makedirs(resized_output_dir, exist_ok=True)

        # Save the resized image with the original destination image size
        resized_output_file = osp.join(resized_output_dir, f'resized_{osp.basename(output_file)}')
        cv2.imwrite(resized_output_file, resized_image)
        print("Output image resized to the original destination image size.")

        # Remove the original output file
        if os.path.exists(output_file):
            os.remove(output_file)

        # Remove the enhanced output file
        if os.path.exists(enhanced_output_file):
            os.remove(enhanced_output_file)

        # Return the path to the resized image relative to the output directory
        return osp.relpath(resized_output_file, output_dir)
    else:
        print("Error: The image could not be resized.")
        return None

def process_images(source_image, destination_image, enhance_method):
    output_dir = os.getcwd()

    # Save the uploaded images
    source_image.save(source_image_path)
    destination_image.save(destination_image_path)

    print("Running enhancement script...")
    output_image_path = faceoff(source_image_path, destination_image_path, output_dir, enhance_method)

    if output_image_path is not None:
        try:
            # Load the output image using the Image module
            output_image = Image.open(output_image_path)

            # Return the output image as a list of one element
            return [(output_image, "Output Image")]
        except Exception as e:
            print(f"Error: Failed to open the output image. {e}")
    else:
        print("Error: FaceOff process failed.")

    # Return an empty list if there was an error
    return []

def cleanup():
    # Remove source image
    if os.path.exists(source_image_path):
        os.remove(source_image_path)

    # Remove destination image
    if os.path.exists(destination_image_path):
        os.remove(destination_image_path)

    # Remove output folders inside final_results directory (***not working***)
    final_results_dir = osp.join(os.getcwd(), "results", "test_img_1.0", "final_results, output_*")
    if os.path.exists(final_results_dir):
        for folder_name in os.listdir(final_results_dir):
            folder_path = osp.join(final_results_dir, folder_name)
            if osp.isdir(folder_path) and folder_name.startswith("output_"):
                shutil.rmtree(folder_path)

iface = gr.Interface(
    fn=process_images,
    inputs=[
        gr.inputs.Image(label="Source Image", type="pil"),
        gr.inputs.Image(label="Destination Image", type="pil"),
        gr.inputs.Radio(["Real-ESRGAN", "CodeFormer"], label="Enhancement Method")
    ],
    outputs=gr.Gallery(label="Output Image Gallery"),
    title="FaceOff Img2Img",
    description="Swap faces between two images. Glasses and objects that obstruct the destination face are no bueno"
)

if __name__ == "__main__":
    iface.launch(server_port=5000)
